#!/bin/bash

# Arguments from the worker
TIME_LIMIT_SECONDS=$1
MEMORY_LIMIT_KB=$2
SOURCE_FILE_BASENAME=$3 # e.g., "Main.cpp"

# --- Setup ---
SANDBOX_DIR="/sandbox"
INPUT_FILE="${SANDBOX_DIR}/input.txt"
SEPARATOR="---|||---"

# Work directly in the sandbox; no need for subdirectories or copying files.
cd "$SANDBOX_DIR"

# --- 1. Compilation ---
COMPILER_OUTPUT_FILE="compiler_errors.txt"
COMPILED_EXECUTABLE="compiled_app"

# Compile the C++ code with optimizations and modern standards.
# Redirect stderr (compilation errors) to a log file.
g++ -O2 -std=c++17 -Wall "${SOURCE_FILE_BASENAME}" -o "${COMPILED_EXECUTABLE}" 2> "${COMPILER_OUTPUT_FILE}"
COMPILATION_EXIT_CODE=$?

# If compilation fails, report the error and exit cleanly.
if [ $COMPILATION_EXIT_CODE -ne 0 ]; then
  echo "COMPILATION_ERROR"
  echo "0.00"
  echo "0"
  echo "${SEPARATOR}"
  echo -n "$(cat "${COMPILER_OUTPUT_FILE}")"
  exit 0
fi

# --- 2. Execution ---
USER_STDOUT_FILE="user_stdout.txt"
USER_STDERR_FILE="user_stderr.txt"
STATS_FILE="stats.txt"

# Run the compiled program inside a subshell with resource limits.
# ulimit sets the memory limit for the process.
# /usr/bin/time measures the actual resources used.
# timeout enforces the time limit.
(
  ulimit -v "${MEMORY_LIMIT_KB}";
  /usr/bin/time -f "%e %M" -o "${STATS_FILE}" \
  timeout -s KILL "${TIME_LIMIT_SECONDS}s" \
  "./${COMPILED_EXECUTABLE}" < "${INPUT_FILE}" > "${USER_STDOUT_FILE}" 2> "${USER_STDERR_FILE}"
)
# The exit code of the subshell will reflect the exit code of the `timeout` command.
EXECUTION_EXIT_CODE=$?

# --- 3. Result Processing ---
EXEC_TIME_SECONDS="0.00"
PEAK_MEMORY_KB="0"

# Safely read the stats from the file generated by /usr/bin/time
if [ -f "$STATS_FILE" ]; then
    read -r EXEC_TIME_SECONDS PEAK_MEMORY_KB < "$STATS_FILE"
    EXEC_TIME_SECONDS=${EXEC_TIME_SECONDS:-0}
    PEAK_MEMORY_KB=${PEAK_MEMORY_KB:-0}
fi

STATUS=""
FINAL_OUTPUT=""

# Determine the final status based on exit codes and resource usage.
if [ "$EXECUTION_EXIT_CODE" -eq 137 ] || [ "$EXECUTION_EXIT_CODE" -eq 124 ]; then
    STATUS="TIME_LIMIT_EXCEEDED"
    FINAL_OUTPUT=$(cat "$USER_STDERR_FILE")
    EXEC_TIME_SECONDS=$TIME_LIMIT_SECONDS
elif [ "$PEAK_MEMORY_KB" -gt "$MEMORY_LIMIT_KB" ]; then
    STATUS="MEMORY_LIMIT_EXCEEDED"
    FINAL_OUTPUT=$(cat "$USER_STDERR_FILE")
elif [ "$EXECUTION_EXIT_CODE" -ne 0 ]; then
    STATUS="RUNTIME_ERROR"
    FINAL_OUTPUT=$(cat "$USER_STDERR_FILE")
else
    STATUS="EXECUTED_SUCCESSFULLY"
    FINAL_OUTPUT=$(cat "$USER_STDOUT_FILE")
fi

# Print the final standardized output for the Node.js worker to parse.
echo "${STATUS}"
echo "${EXEC_TIME_SECONDS}"
echo "${PEAK_MEMORY_KB}"
echo "${SEPARATOR}"
echo -n "${FINAL_OUTPUT}"

exit 0